# A program which computes the Discrete Fourier Transform (DFT) of the provided public inputs.
# We only allow input sizes of a power of 2 for convenience of computing the primitive root of unity.
# This program makes use of the fact that the modulus for the Miden VM's prime field is 2^64 - 2^32 + 1.
#
# See the corresponding Wikipedia article: https://en.wikipedia.org/wiki/Discrete_Fourier_transform_over_a_ring
#
# Expects the input stack to be
# Input: [<length of list>, <ele 0>, <ele 1>, ...]
# 
# Ouputs the Discrete Fourier Transform of the original list, which is a list of the same length.
# Output: [<ele 0'>, <ele 1'>, ...]
#
# Convention: inputs are always consumed by the callee

# Root of unity for domain of 2^32 elements, taken from Winterfell. See:
# https://github.com/facebook/winterfell/blob/4543689f73a2efb9d30927535de7b4efe7e1802d/math/src/field/f64/mod.rs#L270
const.TWO_ADIC_ROOT_OF_UNITY=7277203076849721926

# This means there's a multiplicative subgroup of size 2^32 that exists in the field.
# For more information about two-adicity, see https://cryptologie.net/article/559/whats-two-adicity/.
const.TWO_ADICITY=32

#! Computes the primitive root of unity for a subgroup of size 2^n.
#!
#! Input: n, the size of the input list (must be <= 32)
#! Output: Places the primitive root of unity of order 2^n on the stack
#!
#! Equivalent to Winterfell's implementation: 
#! https://github.com/facebook/winterfell/blob/4543689f73a2efb9d30927535de7b4efe7e1802d/math/src/field/traits.rs#L254-L259
proc.get_root_of_unity
    push.TWO_ADIC_ROOT_OF_UNITY.TWO_ADICITY     # stack: [TWO_ADICITY, TWO_ADIC_ROOT_OF_UNITY, n]
    movup.2                                     # stack: [n, TWO_ADICITY, TWO_ADIC_ROOT_OF_UNITY]
    sub                                         # stack: [TWO_ADICITY - n, TWO_ADIC_ROOT_OF_UNITY]
    pow2                                        # stack: [2^(TWO_ADICITY - n), TWO_ADIC_ROOT_OF_UNITY]
    exp                                         # stack: [TWO_ADIC_ROOT_OF_UNITY^(2^(TWO_ADICITY - n))]
end

#! Computes the kth element of the "frequency domain" (i.e. of the transformed list).
#!
#! Input: [k, root_of_unity, n, v_0, ..., v_{n-1}, ...]
#! Output: [f_k, ...]
#!
#! Locals
#! 0: k
#! 1: root_of_unity
#! 2: n (length of the list)
#! 3: j (counter)
#! 4: result (partial result of the computation)
proc.f_k.5
    loc_store.0                                # store k
    loc_store.1                                # store root_of_unity
    loc_store.2                                # store n
    push.0
    loc_store.3                                # store j, initialized to 0
    push.0
    loc_store.4                                # store result, initialized to 0

    # Stack here: [v0, ..., v{n-1}, ...]

    push.1                                     # push 1 to enter the loop
    while.true
        # compute `root_of_unity^(jk)`
        loc_load.1                             # load root_of_unity
        loc_load.0                             # load k
        loc_load.3                             # load j
        mul                                    # compute j*k
        exp                                    # compute root_of_unity^(jk)
        mul                                    # compute v{j} * root_of_unity^(jk)

        # update result
        loc_load.4                             # load result
        add                                    # sum previous partial result with v{j} * root_of_unity^(jk)
        loc_store.4                            # store partial result

        # Stack here: [v{j+1}, ..., v{n-1}, ...]

        # Update j
        loc_load.3                             # load j
        add.1                                  # increment j by 1
        dup                                    # dup before store to keep j+1 on stack
        loc_store.3                            # store j+1

        # Check if we're done looping
        loc_load.2                             # load n. stack: [n, j+1, ...]
        neq                                     # Check if j+1 != n; if so, we continue. Else, we're done.
    end

    # Return result
    loc_load.4                                 # load result
end

begin
    dup                                        # duplicate n (size of the input list)
    exec.get_root_of_unity

    push.0                                     # push 0

    # stack: [k=0, , root_of_unity, n, v_0, ..., v_{n-1}]
    exec.f_k
end